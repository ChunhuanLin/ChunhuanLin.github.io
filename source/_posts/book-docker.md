---
title: 《Docker-从入门到实践》 
date: 2018-09-05 15:50:55
tags:
- docker
- notes
- tools
categories:
- book
---

## 基本概念
三个基本概念：镜像（Image）、容器（Container）、仓库（Repository）
### Docker镜像
操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu 16.04 最小系统的 root 文件系统。
Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。
#### 分层存储
镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。
分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。
### Docker容器
镜像（ Image ）和容器（ Container ）的关系，就像是面向对象程序设计中的 类 和 实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。
容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，
在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。
容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。
按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。
数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。
### Docker Registry
一个 Docker Registry 中可以包含多个仓库（ Repository ）；每个仓库可以包含多个标签（ Tag ）；每个标签对应一个镜像。
通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <仓库名>:<标签> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。
仓库名经常以 两段式路径 形式出现，比如 jwilder/nginx-proxy ，前者往往意味着 Docker　Registry 多用户环境下的用户名，后者则往往是对应的软件名。
#### Docker Registry 公开服务
最常使用的 Registry 公开服务是官方的 Docker Hub，这也是默认的 Registry，并拥有大量的高质量的官方镜像。除此以外，还有 CoreOS 的 Quay.io，CoreOS 相关的镜像存储在这里；Google 的 Google Container Registry，Kubernetes 的镜像使用的就是这个服务。
由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（ Registry Mirror ），这些镜像服务被称为加速器。常见的有 阿里云加速器、DaoCloud 加速器 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。
#### 私有 Docker Registry
除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了Docker Registry 镜像，可以直接使用做为私有 Registry 服务。
#### 高级服务
开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。在官方的商业化版本 Docker Trusted Registry 中，提供了这些高级功能。
除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，VMWare Harbor 和 Sonatype Nexus。

## 安装Docker
详情见书籍，注意使用国内源，并配置加速器

## 使用镜像
### 获取镜像
`docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]`
* 选项：`docker pull --help`查看
* Docker 镜像仓库地址：地址的格式一般是 <域名/IP>[:端口号] 。默认地址是 Docker Hub
* 仓库名：如之前所说，这里的仓库名是两段式名称，即 <用户名>/<软件名> 。对于 Docker Hub，如果不给出用户名，则默认为 library ，也就是官方镜像 
### 运行
`docker run -it --rm ubuntu:16.04 bash`
* -it ：这是两个参数，一个是 -i ：交互式操作，一个是 -t 终端。我们这里打算进入bash 执行一些命令并查看返回结果，因此我们需要交互式终端。
* --rm ：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm 。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 --rm 可以避免浪费空间。
* ubuntu:16.04 ：这是指用 ubuntu:16.04 镜像为基础来启动容器。
* bash ：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash 。
### 列出镜像
`docker image ls`
#### 镜像体积
* docker image ls
- Docker Hub上是压缩体积，而本地是展开后的体积，因此本地大
- 由于镜像的多层结构，有一些可以继承、复用，因此实际占用空间小于列表中显示的空间总和
* docker system df
- 便捷的查看镜像、容器、数据卷所占用的空间
#### 虚悬镜像
* 特点：仓库名、标签等信息都是<none>
* 显示这类镜像：docker image ls -f dangling=true
* 产生原因：旧镜像名称与新镜像同名，故被抹去信息
* 产生环境：docker pull或docker build时，可能产生这种现象
* 删除：docker image prune
#### 中间层镜像
* docker image ls -a 将会把中间层镜像也显示出来
* 特点：无标签
* 删除： 不能删除此类镜像，在将依赖他们的镜像删除后，他们自然会被删除
#### 列出部分镜像
* 根据仓库名：docker iamge ls <仓库名>
* 指定仓库名和标签：docker image ls <仓库名：标签>
* 过滤器：加入--filter或-f参数，常用的filter参数有：since/before/label等
* 只列出id: -q参数
* 按一定格式输出，--format 参数， 并利用GO的模板语法
### 删除本地镜像
`docker image rm [选项] <镜像1> [<镜像2> ...]`
#### 用ID、镜像名、摘要删除镜像
* 短ID和长ID
- 可以用镜像的长ID，也即完整ID
- 更方便的，可以用短ID，即长ID的前几位（一般3位），只要能够区分不同镜像即可。
* 镜像名
- 即<仓库名>:<标签>
* 镜像摘要
- `docker iamge ls --digests` 列出摘要
- 
## 操作容器

## 访问仓库

## 数据管理
## 使用网络
